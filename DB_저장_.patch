Index: app/src/main/java/ucla/remap/ndnfit/db/DBManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/ucla/remap/ndnfit/db/DBManager.java	(revision )
+++ app/src/main/java/ucla/remap/ndnfit/db/DBManager.java	(revision )
@@ -0,0 +1,179 @@
+/**
+ * Created by nightzen on 4/22/15.
+ */
+
+package ucla.remap.ndnfit.db;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.util.Log;
+import android.widget.Toast;
+
+import java.io.Serializable;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+
+public class DBManager implements Serializable{
+
+    private SQLiteDatabase mDB;
+    private Context mCtx;
+
+    private static final String DB_NAME = "ndnfit.db";
+    private static final String POINT_TABLE = "t_point";
+    private static final String TAG = "DBManager";
+    private static final String TURN_TABLE = "t_turn";
+    private int currentTurn;
+
+    private static DBManager instance = new DBManager();
+
+    private DBManager(){
+    }
+
+    public static DBManager getInstance( ) {
+        return instance;
+    }
+
+    public void init(Context ctx) {
+        mCtx = ctx;
+        prepareDB();
+        createTable();
+    }
+
+    public void prepareDB() {
+        mDB = mCtx.openOrCreateDatabase(DB_NAME, Context.MODE_PRIVATE, null);
+    }
+
+    /**
+     * Check if the tables are already created.
+     * @return true if the tables are existed or false.
+     */
+    public boolean isTurnTableCreated() {
+        Cursor cursor = mDB.rawQuery("select DISTINCT tbl_name from sqlite_master where tbl_name = '" + TURN_TABLE + "'", null);
+        if (cursor != null) {
+            if (cursor.getCount() > 0) {
+                cursor.close();
+                return true;
+            }
+            cursor.close();
+        }
+        return false;
+    }
+
+    protected boolean isPointTableCreated() {
+        Cursor cursor = mDB.rawQuery("select DISTINCT tbl_name from sqlite_master where tbl_name = '"+ POINT_TABLE +"'", null);
+        if(cursor!=null) {
+            if(cursor.getCount()>0) {
+                cursor.close();
+                return true;
+            }
+            cursor.close();
+        }
+        return false;
+    }
+
+    /**
+     * Create target tables.
+     */
+    public void createTable() {
+        if(!isTurnTableCreated()) {
+            mDB.execSQL("create table " + TURN_TABLE + "("
+                            + " id integer PRIMARY KEY autoincrement, "
+                            + " start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
+                            + " finish_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP);"
+            );
+        }
+
+        if(!isPointTableCreated()) {
+            mDB.execSQL("create table " + POINT_TABLE + "("
+                            + " id integer PRIMARY KEY autoincrement, "
+                            + " lat double, "
+                            + " lon double, "
+                            + " turn_id integer, "
+                            + " point_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
+                            + " FOREIGN KEY(turn_id) REFERENCES " + TURN_TABLE + "(id));"
+            );
+        }
+    }
+
+    /**
+     * When a tracking is started, new turn record is inserted.
+     * @return the row ID of the newly inserted row, or -1 if an error occurred
+     */
+    public void startTrack() {
+        ContentValues record = new ContentValues();
+
+        record.put("start_time", System.currentTimeMillis());
+        currentTurn = (int)mDB.insert(TURN_TABLE, null, record);
+    }
+
+    /**
+     * When a tracking is finished, the finish time is updated.
+     */
+    public void finishTrack() {
+        ContentValues record = new ContentValues();
+
+//        record.put("finish_time", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()) );
+        record.put("finish_time", System.currentTimeMillis());
+        int updatedRows = (int)mDB.update(TURN_TABLE, record, "id "+"="+currentTurn, null);
+    }
+
+    public void recordPoint(double lat, double lon) {
+        ContentValues record = new ContentValues();
+
+        record.put("turn_id", currentTurn);
+        record.put("lat", lat);
+        record.put("lon", lon);
+        record.put("point_time", System.currentTimeMillis());
+
+
+        int rowPosition = (int) mDB.insert(POINT_TABLE, null, record);
+        String msg = "record got inserted:" + currentTurn + "-" + String.valueOf(rowPosition);
+        Toast.makeText(mCtx, msg, Toast.LENGTH_SHORT).show();
+    }
+
+    public Cursor getPoints(int turnId) {
+        String[] columns = {"turn_id", "lat", "lon", "point_time"};
+        return mDB.query(POINT_TABLE, columns, "turn_id "+"="+turnId, null, null, null, null);
+    }
+
+    public Cursor getAllPoints() {
+        String[] columns = {"turn_id", "lat", "lon", "point_time"};
+        return mDB.query(POINT_TABLE, columns, null, null, null, null, null);
+    }
+
+    public Cursor getTurn(int rowId) {
+        String[] columns = {"start_time", "finish_time"};
+        Cursor cursor = mDB.query(TURN_TABLE, columns, "id "+"="+rowId, null, null, null, null);
+        return cursor;
+    }
+
+    public Cursor getAllTurn() {
+        String[] columns = {"id", "start_time", "finish_time"};
+        String orderBy = "id" + " DESC";
+        Cursor cursor = mDB.query(TURN_TABLE, columns, null, null, null, null, orderBy);
+        return cursor;
+    }
+
+    /**
+     * Reset all data
+     */
+    public void resetData() {
+        mDB.execSQL("delete from " + TURN_TABLE);
+        mDB.execSQL("delete from " + POINT_TABLE);
+        Log.i(TAG, "RESET Table");
+    }
+
+    /**
+     * Get the last turn of tracking
+     * @return  last turn's row id
+     */
+    public int getLastTurn() {
+        String[] columns = {"id"};
+        Cursor cursor = mDB.query(TURN_TABLE, columns, null, null, null, null, null);
+        cursor.moveToLast();
+        return cursor.getInt(0);
+    }
+}
